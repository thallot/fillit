/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lst_tetri.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: thallot <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/04/22 15:57:54 by thallot           #+#    #+#             */
/*   Updated: 2019/04/26 12:01:47 by thallot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "fillit.h"

char	*ft_place_min(char *str, int min_x, int min_y)
{
	int i;

	i = 0;
	while (str[i] != '\0')
	{
		if (str[i] == '#')
		{
			(i % 5) < min_x ? min_x = (i % 5) : min_x;
			(i / 5) < min_y ? min_y = (i / 5) : min_y;
		}
		i++;
	}
	i = 0;
	while (str[i] != '\0')
	{
		if (str[i] == '#')
		{
			str[i - min_x - (min_y * 5)] = '#';
			str[i] = '.';
		}
		i++;
	}
	return (str);
}

int		*ft_get_size(char *str)
{
	int i;
	int max_width;
	int max_height;
	int	*size;

	max_width = 0;
	max_height = 0;
	i = 0;
	if (!(size = (int *)ft_memalloc(sizeof(int) * 2)))
		return (NULL);
	while (str[i] != '\0')
	{
		if (str[i] == '#')
		{
			(i % 5) > max_width ? max_width = (i % 5) : max_width;
			(i / 5) > max_height ? max_height = (i / 5) : max_height;
		}
		i++;
	}
	size[0] = max_width + 1;
	size[1] = max_height + 1;
	return (size);
}

char	*ft_delete_point(t_tetri *tetri)
{
	int i;
	int len;
	int height;
	int width;
	char *str;

	width = tetri->width;
	height = tetri->height;
	len = ((width + 1) * height) + 1;
	str = ft_strnew(len);
	i = 0;
	while (i < len)
		str[i++] = '.';
	i = 0;
	while (i < 4)
	{
		str[tetri->pos[i][0] + (tetri->pos[i][1] * 5)] = '#';
		printf(" I : %d", tetri->pos[i][0] + (tetri->pos[i][1] * 5));
		str[tetri->width + (i * width)] = '\n';
		i++;
	}
	return (str);
}

t_tetri	*ft_create_tetri(char *str, int index)
{
	int		i;
	int		compteur;
	t_tetri	*tetri;
	int		*size;

	i = 0;
	compteur = 0;
	if (!(tetri = (t_tetri *)ft_memalloc(sizeof(t_tetri))))
		return (NULL);
	str = ft_place_min(str, 4, 4);
	size = ft_get_size(str);
	tetri->width = size[0];
	tetri->height = size[1];
	tetri->str = ft_strdup(str);
	tetri->str = ft_delete_point(tetri);
	ft_memdel((void **)&size);
	tetri->index = index;
	while (compteur < 4)
	{
		if (str[i] == '#')
		{
			tetri->pos[compteur][0] = i % 5;
			tetri->pos[compteur][1] = i / 5;
			compteur++;
		}
		i++;
	}
	return (tetri);
}

t_tetri	**ft_create_list(char **tetris)
{
	int		i;
	t_tetri **tetri;

	i = 0;
	if (!(tetri = (t_tetri **)ft_memalloc(sizeof(t_tetri *) * 27)))
		return (NULL);
	while (tetris[i])
	{
		tetri[i] = ft_create_tetri(tetris[i], i);
		i++;
	}
	//ft_freetab(tetris);
	return (tetri);
}
